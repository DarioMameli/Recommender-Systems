__author__ = "Dario Mameli"

from lenskit.datasets import ML100K
from lenskit import batch, topn, util
from lenskit import crossfold as xf
from lenskit.algorithms import Recommender, als, item_knn, basic, user_knn, funksvd
import pandas as pd

import matplotlib.pyplot as plt
plt.switch_backend('TkAgg')  # Interactive backend for plotting

# Global variables: algorithms to use
algo_Bias = ("Bias", basic.Bias(damping=5))
algo_ItemItem = ("ItemItem", item_knn.ItemItem(nnbrs=20))
algo_UserUser = ("UserUser", user_knn.UserUser(nnbrs=20))
algo_BiasedMF = ("BiasedMF", als.BiasedMF(features=50))
algo_ImplicitMF = ("ImplicitMF", als.ImplicitMF(features=50))
algo_FunkSVD = ("FunkSVD", funksvd.FunkSVD(features=50))

# The algorithms to use
ALGORITHMS = [
            algo_Bias,
            (algo_ItemItem[0], basic.Fallback([algo_ItemItem[1], algo_Bias[1]])),
            (algo_UserUser[0], basic.Fallback([algo_UserUser[1], algo_Bias[1]])),
            (algo_BiasedMF[0], basic.Fallback([algo_BiasedMF[1], algo_Bias[1]])),
            (algo_ImplicitMF[0], basic.Fallback([algo_ImplicitMF[1], algo_Bias[1]])),
            (algo_FunkSVD[0], basic.Fallback([algo_FunkSVD[1], algo_Bias[1]])),
]


def eval(aname, algo, train, test):
    """
    Evaluate a recommender algorithm on test data.

    Parameters:
        aname (str): Name of the algorithm.
        algo: The recommender algorithm to evaluate.
        train (pandas.DataFrame): Training data.
        test (pandas.DataFrame): Test data.

    Returns:
        pandas.DataFrame: Recommendations generated by the algorithm.
    """
    print(f"Evaluating algorithm {aname}..")
    fittable = util.clone(algo)
    fittable = Recommender.adapt(fittable)
    fittable.fit(train)
    users = test.user.unique()
    # now we run the recommender
    recs = batch.recommend(fittable, users, 100)
    # add the algorithm name for analyzability
    recs['Algorithm'] = aname
    print("Done.")
    return recs


def read_dataset(path):
    """
        Function that reads the dataset from a specified path and stores it in a DataFrame

        Parameters:
        path (string): The path to the dataset.

        Returns:
        DataFrame: The dataset in a suitable format for manipulation.
    """
    print(f"Reading dataset at: {path}")

    ml100k = ML100K(path)

    ratings = ml100k.ratings

    print("Done.")

    return ratings


class LensKitRecommender:
    """
        The LensKit recommender containing the functions to execute.
    """

    def __init__(self, pathToRatingsDataset):
        """
            Initialize the LensKitRecommender with the ratings dataset and algorithms to use.

            Parameters:
            - pathToRatingsDataset (str): The path to the ratings' dataset.
        """

        # Dataframe containing the ratings dataset
        self.ratings = read_dataset(pathToRatingsDataset)

        self.algorithms = ALGORITHMS

    def evaluate_recommendations(self):
        """
        Evaluate recommendations generated by multiple algorithms using cross-validation.

        """
        all_recs = []
        test_data = []
        iter_ = 1
        for train, test in xf.partition_users(self.ratings[['user', 'item', 'rating']], 5, xf.SampleFrac(0.2)):
            print("-" * 20, f"CV iter {iter_}", "-" * 20, "\n")
            test_data.append(test)
            for algo in self.algorithms:
                all_recs.append(eval(algo[0], algo[1], train, test))
            print()
            iter_ += 1

        all_recs = pd.concat(all_recs, ignore_index=True)
        print(all_recs.head())
        print()

        test_data = pd.concat(test_data, ignore_index=True)

        rla = topn.RecListAnalysis()
        rla.add_metric(topn.ndcg)
        results = rla.compute(all_recs, test_data)
        print(results.head())
        print()

        print(results.groupby('Algorithm').ndcg.mean())
        print()

        results.groupby('Algorithm').ndcg.mean().plot.bar()

        plt.title("nDCG mean across algorithms")

        plt.show()

    def predict_for_user(self, userID, itemID, algorithm_name):
        """
        Predict the rating score for a specific user-item pair using the specified algorithm.

        Parameters:
        - userID (int): The ID of the user.
        - itemID (int): The ID of the item.
        - algorithm_name (str): The name of the algorithm to use for prediction.

        Returns:
        - score (float): The predicted rating score for the user-item pair.
        """
        algorithm = None
        for alg in self.algorithms:
            if alg[0] == algorithm_name:
                algorithm = alg
        if algorithm is None:
            raise NotImplementedError("The algorithm for the specified name is not implemented.")

        print("-" * 25, algorithm[0], "-" * 25)

        print(f"Fitting {algorithm[0]}..")
        fittable = util.clone(algorithm[1])
        fittable = Recommender.adapt(fittable)
        fittable.fit(self.ratings)
        print("Done.")

        itemID_list = [itemID]

        user_data = self.ratings[self.ratings['user'] == userID]

        user_series = user_data.set_index('item')['rating']

        print(f"Computing score for user {userID}, item {itemID}..")
        score = fittable.predict_for_user(userID, itemID_list, ratings=user_series)
        print("Done.")

        return score

    def predict_for_user_withRandom(self, userID, itemID):
        """
        Functions to demonstrate the impossibility of predict a rating score for a specific user-item pair using the
        Random algorithm, and finally return random recommendations.

        Parameters:
        - userID (int): The ID of the user.
        - itemID (int): The ID of the item.

        Returns:
        - score (float or pd.Series): The predicted rating score for the user-item pair, or recommendations from
        Random algorithm.
        """
        algorithm = ("Random", basic.Random())

        print("-" * 25, algorithm[0], "-" * 25)

        print(f"Fitting {algorithm[0]}..")
        fittable = util.clone(algorithm[1])
        fittable = Recommender.adapt(fittable)
        fittable.fit(self.ratings)
        print("Done.")

        print(f"Computing score for user {userID}, item {itemID}..")
        try:
            itemID_list = [itemID]
            user_data = self.ratings[self.ratings['user'] == userID]
            user_series = user_data.set_index('item')['rating']
            score = fittable.predict_for_user(userID, itemID_list, ratings=user_series)
            print("Done.")
            return score
        except Exception as e:
            last_line = str(e).splitlines()[-1]
            print(f"{type(e).__name__}: {last_line}")
            print(f"Computing recommendations for user {userID}..")
            scores = fittable.recommend(user=userID)
            print("Done.")
            return scores


